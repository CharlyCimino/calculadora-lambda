\documentclass[a4paper,10pt]{article}
\usepackage{listings}    
\usepackage{fouriernc}
\usepackage{antpolt}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{amsmath}
\usepackage{syntax}
\usepackage{color,soul}

\setcounter{section}{-1}

\lstset{tabsize=4}



\begin{document}

Masaryk University

Faculty of Informatics

{\Huge 
Online Lambda\\Calculus Evaluator
}

Bachelor Thesis

Jakub Kadlecaj

Spring 2018

DRAFT

\newpage
\tableofcontents
\newpage

\section{Introduction}

Lambda calculus is a formal system of logic, concerned with functions described as
substitution-based evaluation rules. It plays an important role in computer science
and mathematics, with applications in other fields, such as linguistics 
and philosophy.

The aim of this thesis is to design and implement a web application that evaluates
user-input lambda calculus terms, both pure and typed, with a possibility of
selecting a particular evaluation strategy and step-by-step evaluation, 
multiple importing and exporting options, and several other features lacking 
in publicly available preexisting solutions. The application should be useful to students of
the course \textit{IA014~--~Advanced Functional Programming}, as it is intended to aid in the understanding
of fundamental principles of lambda calculus taught therein.

Firstly, a general overview of the importance of $\lambda$-calculus will be presented,
including, to some extent overlapping topics of historical significance 
and real-world applications---especially usage in
programming languages, then a rigorous definition of lambda calculus' syntax and semantics, together with
descriptions of the implemented evaluation strategies, type systems, and extensions will be provided,
and lastly, a thorough description of the evaluator application itself will be given. In the appendix,
one can find examples of some of the possible inputs to the application, together with more
nuanced and comprehensive characterization of the evaluator, potentially serving as a reference manual.
\newpage

\section{Background}
\subsection{Historical Significance}
kleene rosser paradox

computability

turing machinas

montague and linguistics and TIL

\subsection{Real-World Applications}

lambda funcs in modern langs

robert milner, ML

huskel

lisp

\section{Lambda Calculus}
\subsection{Pure Lambda Calculus}

\subsubsection{Term Syntax}
The language of $\lambda$-calculus, called $\Lambda$, is generated by the following
grammar, written in Backus-Naur form, consisting of only three rules:
\setlength{\grammarindent}{5.2em}
\begin{grammar}
<term> ::= <variable> 
\alt ($\lambda$<variabe>.<term>) 
\alt (<term> <term>) 
\end{grammar}
For instance, $(\lambda x.z)$, $(rr)$, and $((\lambda x.x)\;(\lambda x.(x\;x)))$ are syntactically correct words.

\hl{parameter argument function, function body, grammar rule names }

Generally, a \textit{variable} could be any unambiguous identifier 
that is a member of a chosen countable set, but in this work, the set
of variables is restricted to
lowercase characters optionally followed by a numerical subscript,
as the general case could interfere with the syntactic conventions
of which the definition is given in the following section.

\subsubsection{Syntactic Conventions} \label{sec:conventions}
To make terms more succinct and convenient to write and read, the 
following syntactic conventions are being used:
\begin{align*}
	\lambda x_1 x_2 x_3\;...\;x_n.M &\equiv (\lambda x_1.(\lambda x_2.(\lambda x_3.(\;...\;(\lambda x_n.M)\;...\;))))\\
	M_1\;M_2\;M_3\;...\;M_n &\equiv (\;...\;((M_1\;M_2)\;M_3)\;...\;M_n)\\
	\lambda x.x_1\;x_2\;...\;x_n &\equiv (\lambda x.(x_1\;x_2\;...\;x_n))
\end{align*}
The intuition behind the first two rules is rather straightforward, as the rules
seemingly emulate process of \textit{currying}, i.e.
translation between function of multiple arguments \textit{(left-hand side)} and multiple
functions of a single argument \textit{(right-hand side)}. Clearly, this is only
a matter of syntactic simplicity and has no effect on the actual semantics.
The third rule necessitates a precedence of the application rule over the abstraction rule.

Terms can also be given a name---the choice of term names, or \textit{aliases}, is restricted to 
strings of uppercase letters, and strings of numerals.
The means of assigning terms to numeral names is described in section \ref{encoding} -- \textit{Church Encoding}.

\subsubsection{Variable Binding and Substitution}
The substitution of one term for another lies at the very heart of $\lambda$-calculus'
evaluation mechanics, as the idea of evaluating a function is expressed via replacing
abstraction-bound variables with the provided argument. A variable $x$ is bound in $M$,
if occurs as an abstraction variable $\lambda x.M$. The lambda symbol is also called
abstraction operator, and $M$ is the scope thereof. In order to define
reductions and reduction strategies later, first the concept of free
and bound variables must be introduced formally, using inductive definition
of function $\mathrm{FV} : \Lambda \to \big\{\{variable\}\big\}$, mapping 
terms to the respective sets of free variables:
\begin{align*}
	\mathrm{FV}(x) &= \{x\} \\
    \mathrm{FV}(M\;N) &= \mathrm{FV}(M) \cup \mathrm{FV}(N) \\
	\mathrm{FV}(\lambda x.M) &= \mathrm{FV}(M) \setminus \{x\}
\end{align*}
\begin{center}
\textit{where $x$ is some variable, and $M$ and $N$ are terms}
\end{center}
For example, $\mathrm{FV}(\lambda x y z.x) = \{\}$, $\mathrm{FV}(\lambda e.y\;e) = \{y\}$,
and $\mathrm{FV}\big((\lambda w.w)\;w\big) = \{w\}$. Some variable $x$ occurring in a term $M$ is
said to be bound, if it is not a member of the set of free variables of the term $M$.
A term $M$, such that $\mathrm{FV}(M) = \{\}$, is called \textit{combinator}.

Although apparently trivial, the substitution of free variables of some term with an another term,
the result being written as $M[x := N]$, can be precarious, for some of the 
free variables of term $N$ can become bound in the resulting term. A simple illustration of this
phenomenon is the following function, $\lambda xy.x$, that could be understood as a function
taking two parameters and returning the first. When this function is partially
applied to a particular argument, $(\lambda xy.x)\;y$, a na\"ive replacement of 
the bound variable $x$ for the argument $y$ would yield
$\lambda y.y$, that is, the identity function, a very different result from the expected function returning
the first, already applied parameter $y$, for any argument. The solution to this problem leads
to renaming variables in the process of $\alpha$-conversion.

\begin{align*}
	x[x := N] &\equiv N\\
	y[x := N] &\equiv N,\;\;\textit{where}\;x \not= y\\
	(M_1\;M_2)[x := N] &\equiv (M_1[x := N])\;(M_2[x := N])\\
	(\lambda x.M)[x := N] &\equiv \lambda x.M\\
	(\lambda y.M)[x := N] &\equiv \lambda y.(M[x := N]),\textit{ where}\;x \not= y, x \not\in \mathrm{FV}(M) \lor y \not\in \mathrm{FV}(N)\\
	(\lambda y.M)[x := N] &\equiv \lambda s.(M[y := s][x := N]),\textit{ where}\;x \not= y, x\in \mathrm{FV}(M) \land y \in \mathrm{FV}(N)
\end{align*}
\begin{center}
\textit{in the last rule, the variable $s$ stands for such a variable $y_n$,
\\where $n$ is the least natural number such that $y_n \not\in \mathrm{FV}(M) \land y_n \not\in \mathrm{FV}(N)$}
\end{center}

\subsubsection{Reductions and Reduction Strategies}

reduction strats
church rosser

\subsubsection{Church Encoding}
Church encoding is a means of representing data, and operation on them, using
only pure lambda calculus. Because of the simplicity of the evaluation rules, the powerfulness
and expressivity, with which the data and operations are encoded, may be unexpected.

\paragraph{Church Booleans and logic operators}~\\

$\mathrm{TRUE} \equiv \lambda xy.x$, and $\mathrm{FALSE} \equiv \lambda xy.y$.

After the Boolean values are established, the definition of the fundamental
logic operators is desired. It is required that $\mathrm{OR}\;M\;N$ 
\textit{(logical disjunction written in prefix notation)} will
reduce to $\mathrm{TRUE}$ if $M$ and $N$ are Church-encoded Boolean values,
or could be reduced into them,
and at least one of the terms $M$ and $N$ can be reduced to $\mathrm{TRUE}$.
Because, in pure lambda calculus, there is no guarantee of validity of
the operands, there is no way of predicting the result of an application to
an incorrect argument. \textit{(Later, the problem will be solved by typing
the expressions in section \ref{sec:types} -- Type Systems)}. A term adhering to
such requirements is:
\begin{align*}
	\mathrm{OR} &\equiv \lambda y x. y\;y\;x\\
	\textit{and similarly, }\mathrm{AND} &\equiv \lambda y x. y\;x\;y
\end{align*}
Another useful construct is a conditional, here expressed as a ternary function
of which the first argument is the Boolean condition itself, returning one
of the remaining arguments based on the condition. The definition of
$\mathrm{ITE}$ \textit{(if---then---else)} is as follows:
\begin{align*}
	\mathrm{ITE} \equiv \lambda xyz.xyz
\end{align*}
This term makes use of the property of $\mathrm{TRUE}$ and $\mathrm{FALSE}$
returning the first, respectively the second, of the two arguments.

\paragraph{Church numerals and arithmetic}~\\ \label{encoding}
\subsubsection{Recursion}
\subsubsection{Implemented Extensions and Syntactic Sugar}
\paragraph{Constants}~\\
\paragraph{\textit{Let} expressions}~\\
\subsection{Type Systems} \label{sec:types}
\subsubsection{Simply-Typed }
\subsubsection{Hindley-Milner type system}

\section{Evaluator}
The purpose of the implemented Lambda Calculus Evaluator,
further simply \textit{the application}, is to evaluate $\lambda$-calculus
terms input by a user.
The application provides functionality to
choose an evaluation strategy, toggle between different modes
of term-display, including rendering aliased terms as the alias name,
or the term it represents, and between full-parenthesized terms over
the shorthand form, as presented in section \ref{sec:conventions} -- \textit{Syntactic Conventions}.

Besides the pure, untyped $\lambda$-calculus, a user can also select one of the two
type systems, \textit{Simply-Typed Lambda Calculus} and \textit{Hindley-Milner Type System},
described in section \ref{sec:types}, which halts the execution if the term is typed incorrectly or the type cannot
be deduced, effectively stopping an evaluation of inconsistent terms.

\subsection{Technical Aspects}
Using the three core web development technologies,
HTML \textit{(Hypertext Markup Language)}, CSS \textit{(Cascading Style Sheets)}, and JavaScript,
the evaluator is built as a single-page application,
i.e. an application using solely dynamic modifications of the content of the current page,
as opposed to redirecting, reloading, or downloading a page with a new content.
Using web browsers as an application platform contributes
to the application's compatibility and availability, 
as there is no need for an installation on the target system.
The application is executed exclusively on the client-side,
in a potential case of an actual deployment alleviating the server load on one hand,
allowing the downloading and subsequent offline usage by a user on the other.

To tightly control the application's typography across different system, 
the \textit{Computer Modern} typeface is distributed along the application, allowing
for consistent user experience and arguably {\ae}sthetically pleasing visual appearance of the application.

\subsection{Features}

info bar

help page

\subsection{User Interface}
\subsubsection{Parsing User's Input}

\subsubsection{Evaluation}
After a syntactically valid term has been submitted, one can commence and repeat
the manual, step-by-step evaluation by
mouse-clicking the desired redex inside the expression until the normal form is reached.
If an evaluation strategy other than the \textit{Full Beta Reduction} is selected, 
it is possible to select at most one redex. The presence of a redex inside a term is
indicated by an argument- and function color outline, shown on mouse-hover, as illustrated
in figure \hl{F I G U R E}. Different kinds of redexes are indicated by an outline of different colors.
As some of the evaluation chains, or \textit{derivations},
can be rather long, in some cases using
only step-by-step evaluation would be tiring, or even altogether unfeasible.
To directly evaluate a term at once, one can simply click on a asterisk-arrow following
a reducible term. If a derivation is short enough, precisely, less that 50 evaluation steps,
each evaluation step will be rendered as a line, otherwise, only the normal form
will be appended to the already rendered derivation, and the information
about the number of taken evaluation steps needed to reach the normal form will be
displayed on the bottom panel.

A summary information about the number of possible redexes
on the current line, their type, and, being selected a type system, type of the evaluated term
is presented on the bottom panel.

\subsubsection{Alias management}

\subsubsection{Display Settings}
alias expansion and shorthand

\subsubsection{Input \& Output}
At times, one may wish to store an evaluation chain for later retrieval, print the derivation,
or export it as a \LaTeX\;source.
The printing and \LaTeX\;source generation functionality uses the active display settings,
namely the \textit{alias expansion} and \textit{shorthand form}, thus making exporting
facility as flexible as the web application itself.

\subsection{Web Browser Compatibility}
\subsection{Comparison with Existing Solutions}

\section{Conclusion}
It's done, thank you.

\appendix
\section{Examples and Reference Manual}

\end{document}
