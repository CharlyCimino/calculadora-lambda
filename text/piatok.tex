\documentclass[a4paper,10pt]{article}
\usepackage{listings}    
\usepackage{fouriernc}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{amsmath}
\usepackage{syntax}
\usepackage{color,soul}

\setcounter{section}{-1}

\lstset{tabsize=4}



\begin{document}

Masaryk University

Faculty of Informatics

{\Huge 
Online Lambda\\Calculus Evaluator
}

Bachelor Thesis

Jakub Kadlecaj

Spring 2018

DRAFT

\newpage
\tableofcontents
\newpage

\section{Introduction}

Lambda calculus is a formal system of logic, concerned with functions described as
substitution-based evaluation rules. It plays an important role in computer science
and mathematics, with applications in other fields, such as linguistics 
and philosophy.

The aim of this thesis is to design and implement a web application that evaluates
user-input lambda calculus terms, both pure and typed, with a possibility of
selecting a particular evaluation strategy and step-by-step evaluation, 
multiple importing and exporting options, and several other features lacking 
in publicly available pre-existing solutions. The application should be useful to students of
the course \textit{IA014~--~Advanced Functional Programming}, as it is intended to aid in the understanding
of fundamental principles of lambda calculus taught therein.

Firstly, a general overview of the importance of $\lambda$-calculus will be presented,
including, to some extent overlapping topics of historical significance 
and real-world applications---especially usage in
programming languages, then a rigorous definition of lambda calculus' syntax and semantics, together with
descriptions of the implemented evaluation strategies, type systems, and extensions will be provided,
and lastly, a thorough description of the evaluator application itself will be given. In the appendix,
one can find examples of some of the possible inputs to the application, together with more
nuanced and comprehensive characterisation of the evaluator, potentially serving as a reference manual.
\newpage

\section{Background}
\subsection{Historical Significance}
kleene rosser paradox

computability

turing machinas

montague and linguistics and TIL

\subsection{Real-World Applications}

lambda funcs in modern langs

robert milner, ML

huskel

lisp

\section{Lambda Calculus}

\subsection{Pure Lambda Calculus}

\subsubsection{Term Syntax}
The language of $\lambda$-calculus is generated by the following
grammar in Backus-Naur form, consisting only of three rules:
\setlength{\grammarindent}{5.2em}
\begin{grammar}
<term> ::= <variable> 
\alt ($\lambda$<variabe>.<term>) 
\alt (<term> <term>) 
\end{grammar}
Generally, a \textit{variable} could be any unambiguous identifier 
that is a member of a chosen countable set, but in this work, the set
of variables is restricted to
lowercase characters optionally followed by a numerical subscript,
as the general case could interfere with the syntactic conventions
of which the definition is given \hl{in the following section}.

\subsubsection{Syntactic Conventions}
To make terms more succinct and convenient to write and read, the 
following syntactic conventions are being used:
\begin{align*}
	\lambda x_1 x_2 x_3\;...\;x_n.M &\equiv (\lambda x_1.(\lambda x_2.(\lambda x_3.(\;...\;(\lambda x_n.M)\;...\;))))\\
	M_1\;M_2\;M_3\;...\;M_n &\equiv (\;...\;((M_1\;M_2)\;M_3)\;...\;M_n)\\
	\lambda x.x_1\;x_2\;...\;x_n &\equiv (\lambda x.(x_1\;x_2\;...\;x_n))
\end{align*}
The intuition behind the first two rules is rather straighforward, as the rules
seemingly emulate process of \textit{currying}, i.e.
translation between function of multiple arguments \textit{(left-hand side)} and multiple
functions of a single argument \textit{(right-hand side)}. Clearly, this is only
a matter of syntactic simplicity and has no effect on the actual semantics.
The third rule necessitates a precedence of the application rule over the abstraction rule.

Terms can also be given a name---the choice of term names, or \textit{aliases}, is restricted to 
strings of uppercase letters, and strings of numerals.
The means of assigning terms to numeral names is described in section \hl{\textit{Church Encoding}}.

\subsubsection{Variable Binding and Substitution}
The substitution of one term for another lies at the very heart of $\lambda$-calculus'
evaluation mechanics. In order to define reductions and reduction strategies
later, the concept of free and bound variables must be introduced first.
%\begin{lstlisting}
%int constant = 8;
%int add_constant(int argument)
%{
%	return argument + constant;
%}
%\end{lstlisting}
\begin{align*}
	\mathrm{FV}(x) &= \{x\} \\
    \mathrm{FV}(M\;N) &= \mathrm{FV}(M) \cup \mathrm{FV}(N) \\
	\mathrm{FV}(\lambda x.M) &= \mathrm{FV}(M) \setminus \{x\}
\end{align*}
\begin{center}
\textit{where x is some variable, and M and N are terms}
\end{center}
For example, $\mathrm{FV}(\lambda x y z.x) = \{\}$, $\mathrm{FV}(\lambda e.y\;e) = \{y\}$,
and $\mathrm{FV}\big((\lambda w.w)\;w\big) = \{w\}$. Some variable $x$ occuring in a term $M$ is
said to be bound, if it is not a member of the set of free variables of the term $M$.

Although apparently trivial, the substitution of free variables of some term with an another term,
the result being written as $M[x := N]$, can be precarious, for some of the 
free variables of term $N$ can become bound in the resulting term. A simple illustration of this
phenomenon is the following function, $\lambda xy.x$, that could be understood as a function
taking two parameters and returning the first. When this function is partially
applied to a particular argument, $(\lambda xy.x)\;y$, na\"ive replacement of 
bound variable $x$ for argument $y$ would yield
$y.y$, that is, the identity function, a very different result from the expected function returning
the first, already applied parameter $y$, for any input. The solution to this problem leads
to renaming variables in the process of $\alpha$-conversion.

\begin{align}
	x[x := N] &\equiv N\\
	y[x := N] &\equiv N,\;\;\textit{where}\;x \not= y\\
	(M_1\;M_2)[x := N] &\equiv (M_1[x := N])\;(M_2[x := N])\\
	(\lambda x.M)[x := N] &\equiv \lambda x.M\\
	(\lambda y.M)[x := N] &\equiv \lambda y.(M[x := N]),\;\;\textit{where}\;x \not= y
\end{align}

\subsubsection{Reductions and Reduction Strategies}

reduction strats
church rosser

\subsubsection{Church Encoding}
\subsubsection{Recursion}
\subsubsection{Implemented Extensions and Syntactic Sugar}

higher order funs

\subsection{Type Systems}
\subsubsection{Simply-Typed }
\subsubsection{Hindley-Milner type system}

\section{Evaluator}
\subsection{Technical Aspects}
javascript lol
\subsection{Features}
info bar

help page


compability table

\subsubsection{User's Input and Parsing}
parser gramamr

\subsubsection{Alias management}

\subsubsection{Display Settings}
alias expansion and shorthand

\subsubsection{Evaluation}
clicking and stuff

\subsubsection{Input \& Output}
using current display settings
printing

latex

files, url
printing

\subsection{Comparision with Existing Solutions}

\section{Conclusion}
It's done, thank you.

\appendix
\section{Examples and Reference Manual}

\end{document}
