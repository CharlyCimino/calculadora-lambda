\documentclass[a4paper,10pt]{article}
\usepackage{listings}    
\usepackage[hidelinks]{hyperref}    
\usepackage{forest}    
\usepackage{biblatex}
\usepackage{fouriernc}
\usepackage{antpolt}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage{xcolor}
\usepackage{soul}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{syntax}
\usepackage{inconsolata}
\usepackage{menukeys}
\usepackage{newunicodechar}

\newunicodechar{Î»}{\ensuremath{\lambda}}

\bibliography{bibdatabase}

%redex kind
\definecolor{betaFunc}{HTML}{8E8FA7}
\definecolor{betaArg}{HTML}{BC8F8F}
\definecolor{delta}{HTML}{98C6A8}
\definecolor{letexpr}{HTML}{E6C79B}
%parser indicator
\definecolor{syngood}{HTML}{8BBB8D}
\definecolor{synbad}{HTML}{E08888}

\lstset{tabsize=4}

\begin{document}
\vspace*{7cm}
\begin{center}
{\Huge 
Online Lambda\\Calculus Evaluator
}

D R A F T
\end{center}

\newpage
\tableofcontents
\newpage

\section{Introduction}
Lambda calculus is a formal system of logic, concerned with functions described as
substitution-based evaluation rules. It plays an important role in computer science
and mathematics, with applications in other fields, such as linguistics 
and philosophy.

The aim of this thesis is to design and implement a web application that evaluates
user-input lambda calculus terms, both pure and typed, with a possibility of
selecting a particular evaluation strategy and step-by-step evaluation, 
multiple importing and exporting options, and several other features lacking 
in publicly available preexisting solutions. The application should be useful to students of
the course \textit{IA014~--~Advanced Functional Programming}, as it is intended to aid in the understanding
of fundamental principles of lambda calculus taught therein.

Firstly, a general overview of the importance of $\lambda$-calculus will be presented,
including, to some extent overlapping topics of historical significance 
and real-world applications---especially usage in
programming languages, then a rigorous definition of lambda calculus' syntax and semantics, together with
descriptions of the implemented evaluation strategies, type systems, and extensions will be provided,
and lastly, a thorough description of the evaluator application itself will be given. In the appendix,
one can find examples of some of the possible inputs to the application, together with more
nuanced and comprehensive characterization of the evaluator, potentially serving as a reference manual.
\newpage

\section{Background}
\subsection{Historical Significance}
kleene rosser paradox

computability

turing machinas

montague and linguistics and TIL

\subsection{Real-World Applications}

lambda funcs in modern langs

robert milner, ML

huskel

lisp

\section{Lambda Calculus}
\subsection{Pure Lambda Calculus}

\subsubsection{Term Syntax}
The language of $\lambda$-calculus, called $\Lambda$, is generated by the following
grammar, written in Backus-Naur form, consisting of only three rules:
\setlength{\grammarindent}{5.2em}
\begin{grammar}
<term> ::= <variable> 
\alt ($\lambda$<variabe>.<term>) 
\alt (<term> <term>) 
\end{grammar}

\hl{parameter argument function, function body, grammar rule names }

Generally, a \textit{variable} could be any unambiguous identifier 
that is a member of a chosen countable set, but in this work, the set
of variables is restricted to
lowercase characters optionally followed by a numerical subscript,
as the general case could interfere with the syntactic conventions
of which the definition is given in the following section.

\subsubsection{Syntactic Conventions} \label{sec:conventions}
To make terms more succinct and convenient to write and read, the 
following syntactic conventions, describing parentheses ommision, are being used:
\begin{align*}
	\lambda x_1 x_2 x_3\;...\;x_n.M &\equiv (\lambda x_1.(\lambda x_2.(\lambda x_3.(\;...\;(\lambda x_n.M)\;...\;))))\\
	M_1\;M_2\;M_3\;...\;M_n &\equiv (\;...\;((M_1\;M_2)\;M_3)\;...\;M_n)\\
	\lambda x.x_1\;x_2\;...\;x_n &\equiv (\lambda x.(x_1\;x_2\;...\;x_n))
\end{align*}
The intuition behind the first two rules is rather straightforward, as the rules
seemingly emulate the process of \textit{currying}, i.e.
translation between function of multiple arguments \textit{(left-hand side)} and multiple
functions of a single argument \textit{(right-hand side)}. Clearly, this is only
a matter of syntactic simplicity and has no effect on the actual semantics.
The third rule necessitates a precedence of the application rule over the abstraction rule.

Terms can also be given a name---the choice of term names, or \textit{aliases}, is restricted to 
strings of uppercase letters, and strings of numerals.
The means of assigning terms to numeral names is described in section \ref{encoding} -- \textit{Church Encoding}.

\subsubsection{Variable Binding and Substitution}
The substitution of one term for another lies at the very heart of $\lambda$-calculus'
evaluation mechanics, as the idea of evaluating a function is expressed via replacing
abstraction-bound variables with the provided argument. A variable $x$ is bound in $M$,
if occurs as an abstraction variable $\lambda x.M$. The lambda symbol is also called
abstraction operator, and $M$ the scope thereof. In order to define
reductions and reduction strategies later, first the concept of free
and bound variables must be introduced formally, using inductive definition
of function $\mathrm{FV} : \Lambda \to \big\{\{variable\}\big\}$, mapping 
terms to the respective sets of free variables in a following manner:
\begin{align*}
	\mathrm{FV}(x) &= \{x\} \\
    \mathrm{FV}(M\;N) &= \mathrm{FV}(M) \cup \mathrm{FV}(N) \\
	\mathrm{FV}(\lambda x.M) &= \mathrm{FV}(M) \setminus \{x\}
\end{align*}
\begin{center}
\textit{where $x$ is some variable, and $M$ and $N$ are terms}
\end{center}
For example, $\mathrm{FV}(\lambda x y z.x) = \{\}$, $\mathrm{FV}(\lambda e.y\;e) = \{y\}$,
and $\mathrm{FV}\big((\lambda w.w)\;w\big) = \{w\}$. Some variable $x$ occurring in a term $M$ is
said to be bound, if it is not a member of the set of free variables of the term $M$.
A term $M$, such that $\mathrm{FV}(M) = \{\}$, is called \textit{combinator}.

Although apparently trivial, the substitution of free variables of some term with an another term,
the result being written as $M[x := N]$, can be precarious, for some of the 
free variables of term $N$ can become bound in the resulting term. A simple illustration of this
phenomenon is the following function, $\lambda xy.x$, that could be understood as a function
taking two parameters and returning the first. When this function is partially
applied to a particular argument, $(\lambda xy.x)\;y$, a na\"ive replacement of 
the bound variable $x$ for the argument $y$ would yield
$\lambda y.y$, that is, the identity function, a very different result from the expected function returning
the first, already applied parameter $y$, for any argument. The solution to this problem leads
to renaming variables in the process of $\alpha$-conversion.

\begin{align*}
	x[x := N] &\equiv N\\
	y[x := N] &\equiv N,\;\;\textit{where}\;x \not= y\\
	(M_1\;M_2)[x := N] &\equiv (M_1[x := N])\;(M_2[x := N])\\
	(\lambda x.M)[x := N] &\equiv \lambda x.M\\
	(\lambda y.M)[x := N] &\equiv \lambda y.(M[x := N]),\textit{ where}\;x \not= y,\;x \not\in \mathrm{FV}(M) \lor y \not\in \mathrm{FV}(N)\\
	(\lambda y.M)[x := N] &\equiv \lambda s.(M[y := s][x := N]),\textit{ where}\;x \not= y,\;x\in \mathrm{FV}(M) \land y \in \mathrm{FV}(N)
\end{align*}
\begin{center}
\textit{in the last rule, the variable $s$ stands for such a variable $y_n$,
\\where $n$ is the least natural number such that $y_n \not\in \mathrm{FV}(M) \land y_n \not\in \mathrm{FV}(N)$}
\end{center}

%church rosser
\subsubsection{Reductions}
A single evaluation step, expressing the notion of function application, is
formalized via the mechanism of so-called $\beta$\textit{-reduction},
consisting of substitution of abstraction-bound variables with an
application argument. Formally:
\begin{align*}
	(\lambda x.M)\;N \;\to_\beta\; M[x := N]
\end{align*}
The term of the form $(\lambda x.M)\;N$ is called a \textit{redex} (\textit{reducible expression}).
As a redex can appear anywhere inside a term, 


\begin{forest}
for tree={
  	if n children=0{
     	tier=terminal
   	}{}
}
[\textit{app} [\textit{app} [\textit{abs} [$(((\lambda x.$] [$x)$]] [[$z)$]]] [[$z)$]]]
\end{forest}

\subsubsection{Reduction Strategies}
\paragraph{Normal Order}
\paragraph{Applicative Order}
\paragraph{Call by Name}
\paragraph{Call by Value}

\subsubsection{Church Encoding}
Church encoding is a means of representing data, and operation on them, using
only pure lambda calculus. Because of the simplicity of the evaluation rules, the powerfulness
and expressivity, with which the data and operations are encoded, may be unexpected.

\paragraph{Church Booleans and logic operators}
$\mathrm{TRUE} \equiv \lambda xy.x$, and $\mathrm{FALSE} \equiv \lambda xy.y$.
After the Boolean values are established, the definition of the fundamental
logic operators is desired. It is required that $\mathrm{OR}\;M\;N$ 
\textit{(logical disjunction written in prefix notation)} will
reduce to $\mathrm{TRUE}$ if $M$ and $N$ are Church-encoded Boolean values,
or could be reduced into them,
and at least one of the terms $M$ and $N$ can be reduced to $\mathrm{TRUE}$.
Because, in pure lambda calculus, there is no guarantee of validity of
the operands, there is no way of predicting the result of an application to
an incorrect argument. \textit{(Later, the problem will be solved by typing
the expressions in section \ref{sec:types} -- Type Systems)}. A term adhering to
such requirements is:
\begin{align*}
	\mathrm{OR} &\equiv \lambda y x. y\;y\;x\\
	\textit{and similarly, }\mathrm{AND} &\equiv \lambda y x. y\;x\;y
\end{align*}
Another useful construct is a conditional, here expressed as a ternary function
of which the first argument is the Boolean condition itself, returning one
of the remaining arguments based on the condition. The definition of
$\mathrm{ITE}$ \textit{(if---then---else)} is as follows:
\begin{align*}
	\mathrm{ITE} \equiv \lambda xyz.xyz
\end{align*}
This term makes use of the property of $\mathrm{TRUE}$ and $\mathrm{FALSE}$
returning the first, respectively the second, of the two arguments.

\paragraph{Church numerals and arithmetic} \label{encoding}
\subsubsection{Recursion}
\subsubsection{Implemented Extensions and Syntactic Sugar}
\paragraph{Constants}
\paragraph{\textit{Let} expressions}
\subsection{Type Systems} \label{sec:types}
\subsubsection{Simply-Typed Lambda Calculus}
\subsubsection{Hindley-Milner Type System}

\section{Evaluator}
The purpose of the implemented Lambda Calculus Evaluator,
further simply \textit{the application}, is to evaluate $\lambda$-calculus
terms input by a user.
The application provides functionality to
choose an evaluation strategy, toggle between different modes
of term-display, including rendering aliased terms as the alias name,
or the term it represents, and between full-parenthesized terms over
the shorthand form, as presented in section \ref{sec:conventions} -- \textit{Syntactic Conventions}.
An effort was made to develop an ergonomic, easy-to-use application with 
simple yet appealing visuals.

Besides the pure, untyped $\lambda$-calculus, a user can also select one of the two
type systems, \textit{Simply-Typed Lambda Calculus} and \textit{Hindley-Milner Type System},
described in section \ref{sec:types}, which halts the execution if the term is typed incorrectly or the type cannot
be deduced, effectively stopping an evaluation of inconsistent terms.

\subsection{Technical Aspects}
Using the three core web development technologies,
HTML \textit{(Hypertext Markup Language)}, CSS \textit{(Cascading Style Sheets)}, and JavaScript,
the evaluator is built as a single-page application,
i.e. an application using solely dynamic modifications of the content of the current page,
as opposed to redirecting, reloading, or downloading a page with a new content.
Using a web browser as an application platform contributes
to the application's compatibility and availability, 
as there is no need for an installation on the target system.
The application is executed exclusively on the client-side,
in case of an actual deployment alleviating the server load on one hand,
allowing the downloading and subsequent offline usage by a user on the other.

To tightly control the application's typography across many different systems,
the \textit{Computer Modern} typeface is distributed along the application, allowing
for consistent user experience and arguably {\ae}sthetically pleasing visual appearance of the application.

Object-oriented programming paradigm, supported by JavaScript, is employed
to model the data, as \textit{objects} can closely match the term structure,
e.g. a \textit{term} can be represented by an interface, an \textit{abstraction} can
be an implementation thereof, closely matching the lambda calculus' grammar.
Due to the JavaScript's dynamic nature, the mentioned interface is only implicit,
as there is no syntactical support for such a construct in the language itself.

\hl{libraries \& frameworks}

\subsection{Features}
info bar

help page

\subsection{User Interface}
\subsubsection{User's Input}
Upon entering the application, the user can immediately begin to type the expression
to be evaluated. The outline of the input box is colored based on the syntactical
correctness of the input term; {\color{synbad}$\blacksquare$} red on syntactically incorrect,
and {\color{syngood}$\blacksquare$} green on
syntactically correct terms, providing a useful and immediate feedback to the user after
each keystroke. As per the information shown on the entry page, in order to
enter the lambda character, the user simply hits the backslash key, which in turn
gets automatically converted into the lambda character, written into the input box.
The type constructor arrow for \textit{Simply Typed Lambda Calculus} is input
in a similar fashion, using a combination of a hyphen and greater-than sign.

The entry page is also equipped with links, one to the \textit{Help} page, and one specifically
to the \textit{Examples} section. On this page, there is
also possibility to load a previously saved file. A closer look on
available import and export options is given in section \ref{sec:io}.

An option to disambiguate between conflicting Alias- and Constant names is available,
interpreting the names according to the preference set by a user. The default behavior is
to interpret all conflicting names as constants. For instance, the user inputs
a string ``21''. Such a string could represent Church-encoded numeral as well as the primitive
value, defined outside the $\lambda$-calculus. Because the user did not change the default
setting, this string will be parsed as a constant. Occasionally, one may wish
to enter both an alias and a constant. In this case, one can use an exclamation mark
just before the string to indicate the exception to the preference setting.
Assuming the default setting, a string ``!FALSE 12 TRUE'' would be interpreted as
$(\lambda xy.y)\;\textit{12}\;\textit{TRUE}$, the constants being written in italic type.

\hl{grammar and recursive descent, enter to submit}

\subsubsection{Evaluation}
After a syntactically valid term has been submitted, one can commence and repeat
the manual, step-by-step evaluation by
mouse-clicking the desired redex inside the expression until a normal form is reached.
The new, reduced expression will be rendered below the clicked one, together
with an arrow indicator of the redex' kind.
If an evaluation strategy other than the \textit{Full Beta Reduction} is selected, 
it is possible to select at most one redex, as accorded by the evaluation strategy.

Presence of a redex inside a term is
indicated by an argument- and function color outline, shown on mouse-hover, as illustrated
in figure \hl{sprav screenshot}. Different kinds of redexes are indicated by an outline of these different colors,
written as hexadecimal triplets, using the RGB color model:
\begin{center}
\begin{tabular}{ll}
	{\color{delta}$\blacksquare$} \texttt{98c6a8}   &$\delta$-redex\\
	{\color{letexpr}$\blacksquare$} \texttt{e6c79b} &\textit{Let} expression\\
	{\color{betaFunc}$\blacksquare$} \texttt{8e8fa7}&$\beta$-redex' function\\
	{\color{betaArg}$\blacksquare$} \texttt{bc8f8f} &$\beta$-redex' argument
\end{tabular}
\end{center}
The reason behind highlighting the redexes only on mouse-hover, instead of highlighting
them permanently, is twofold: for visual clarity, as a permanent color outline would
create bothersome visual clutter on the screen, and secondly, redexes are
often nested, which would result in confusing outlines bearing no useful information.

As some of the evaluation chains, or \textit{derivations},
can be rather long, in some cases using
only step-by-step evaluation would be tiring, or even altogether unfeasible.
To directly evaluate a term at once, one can simply click on an asterisk-arrow following
a reducible term. If a derivation is short enough, precisely, less than 50 evaluation steps,
each evaluation step will be rendered on a new line, otherwise, only the normal form
will be appended to the already rendered derivation, and the information
about the number of taken evaluation steps needed to reach the normal form will be
displayed on the bottom panel. The selected reduction strategy 
will be used for immediate evaluation, except in the case of \textit{Full Beta Reduction}, where the
\textit{Normal Order} will be used, as it is \textit{complete}---if the normal form does
exist, it will be eventually reached.

A summary information about the number of possible redexes
on the current line, their kind, and, being selected a type system, type of the evaluated term
is presented on the bottom panel.

\subsubsection{Alias Management}

\subsubsection{Display Settings}
alias expansion and shorthand

\subsubsection{Import \& Export} \label{sec:io}
At times, one may wish to store an evaluation chain for later retrieval, print the derivation,
or export it as a \LaTeX\;source.
The printing and \LaTeX\;source generation functionality uses the active display settings,
namely the \textit{alias expansion} and \textit{shorthand form}, thus making the exporting
facility as flexible as the web application's term-displaying abilities themselves.

A quick and convenient way to share a term on a current line is to copy the
URL from the web browser's address bar, as the application does encode
the current term in the URI's optional \textit{fragment} part, initiated with a hash sign (\#).

The import and export options are available via the \texttt{OPTIONS} menu from the head naviagation bar.

\paragraph{File Input and Output}
By user request, a file containing the derivation chain is generated and
downloaded. The file is named \texttt{save.lambda}, and in a human-readable
format holds information about term on every line, what kind of reduction
did produce the term \textit{(the arrow)}, and the type system used.
All of the user-defined aliases are also stored inside the file,
as the aliases may be used to display the saved terms, or simply to
enable users to conveniently reuse the already defined aliases in the future;
this is especially useful with a combination of the initial screen feature,
allowing loading only the aliases from the file, as these can be used for an input
of a new term right away.

\paragraph{\LaTeX\;source code generation}
The evaluation chain is typeset using the \texttt{align*} environment,
available through the popular \texttt{amsmath} package; the user
has to include \verb|\usepackage{amsmath}| declaration in the 
preamble of the document.

Before exporting the derivation, one should make sure the desired
displaying options are in place.

\begin{align*}
&(\lambda x.x)\;\mathrm{FALSE}\;(\lambda y.y)\\
\to_\beta\;&\mathrm{FALSE}\;(\lambda y.y)\\
\to_\eta\;&\lambda y.y
\end{align*}

\begin{verbatim}
      \begin{align*}
                     &(\lambda x.x)\;\mathrm{FALSE}\;(\lambda y.y)\\
          \to_\beta\;&\mathrm{FALSE}\;(\lambda y.y)\\
           \to_\eta\;&\lambda y.y
      \end{align*}
\end{verbatim}

\paragraph{Printing}

\begin{align*}
&(\lambda x.x)\;\mathrm{FALSE}\;(\lambda x.x_{2})
\end{align*}

% don't forget to \usepackage{amsmath}
\begin{align*}
&(\lambda x.\mathrm{ITE}\;x\;x\;x)\;\mathrm{FALSE}\\
\to_\beta\;&(\lambda x.(\lambda yz.x\;y\;z)\;x\;x)\;\mathrm{FALSE}\\
\to_\beta\;&(\lambda x.(\lambda z.x\;x\;z)\;x)\;\mathrm{FALSE}\\
\to_\beta\;&(\lambda x.x\;x\;x)\;\mathrm{FALSE}\\
\to_\beta\;&\mathrm{FALSE}\;\mathrm{FALSE}\;\mathrm{FALSE}\\
\to_\eta\;&(\lambda y.y)\;\mathrm{FALSE}\\
\to_\beta\;&\mathrm{FALSE}
\end{align*}

\subsection{Web Browser Compatibility}
\subsection{Comparison with Existing Solutions}
There are several existing applications for evaluating lambda calculus available online.

\cite{Interpreter1}
\cite{Interpreter2}
\cite{Interpreter3}
\cite{Interpreter4}
\cite{Interpreter5}
\cite{Interpreter6}

\section{Conclusion}
It's done, thank you.

\printbibliography

\appendix
\section{Predefined Constants and Aliases}
\section{Input Examples}

\end{document}
