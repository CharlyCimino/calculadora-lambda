\documentclass[a4paper,10pt]{article}
\usepackage{listings}    
\usepackage{fouriernc}
\usepackage{antpolt}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{amsmath}
\usepackage{syntax}
\usepackage{color,soul}

\setcounter{section}{-1}

\lstset{tabsize=4}



\begin{document}

Masaryk University

Faculty of Informatics

{\Huge 
Online Lambda\\Calculus Evaluator
}

Bachelor Thesis

Jakub Kadlecaj

Spring 2018

DRAFT

\newpage
\tableofcontents
\newpage

\section{Introduction}

Lambda calculus is a formal system of logic, concerned with functions described as
substitution-based evaluation rules. It plays an important role in computer science
and mathematics, with applications in other fields, such as linguistics 
and philosophy.

The aim of this thesis is to design and implement a web application that evaluates
user-input lambda calculus terms, both pure and typed, with a possibility of
selecting a particular evaluation strategy and step-by-step evaluation, 
multiple importing and exporting options, and several other features lacking 
in publicly available preexisting solutions. The application should be useful to students of
the course \textit{IA014~--~Advanced Functional Programming}, as it is intended to aid in the understanding
of fundamental principles of lambda calculus taught therein.

Firstly, a general overview of the importance of $\lambda$-calculus will be presented,
including, to some extent overlapping topics of historical significance 
and real-world applications---especially usage in
programming languages, then a rigorous definition of lambda calculus' syntax and semantics, together with
descriptions of the implemented evaluation strategies, type systems, and extensions will be provided,
and lastly, a thorough description of the evaluator application itself will be given. In the appendix,
one can find examples of some of the possible inputs to the application, together with more
nuanced and comprehensive characterization of the evaluator, potentially serving as a reference manual.
\newpage

\section{Background}
\subsection{Historical Significance}
kleene rosser paradox

computability

turing machinas

montague and linguistics and TIL

\subsection{Real-World Applications}

lambda funcs in modern langs

robert milner, ML

huskel

lisp

\section{Lambda Calculus}

\subsection{Pure Lambda Calculus}

\subsubsection{Term Syntax}
The language of $\lambda$-calculus, called $\Lambda$, is generated by the following
grammar, written in Backus-Naur form, consisting of only three rules:
\setlength{\grammarindent}{5.2em}
\begin{grammar}
<term> ::= <variable> 
\alt ($\lambda$<variabe>.<term>) 
\alt (<term> <term>) 
\end{grammar}
For instance, $(\lambda x.z)$, $(rr)$, and $((\lambda x.x)\;(\lambda x.(x\;x)))$ are syntactically correct words.

\hl{parameter argument function, function body, grammar rule names }

Generally, a \textit{variable} could be any unambiguous identifier 
that is a member of a chosen countable set, but in this work, the set
of variables is restricted to
lowercase characters optionally followed by a numerical subscript,
as the general case could interfere with the syntactic conventions
of which the definition is given in the following section.

\subsubsection{Syntactic Conventions}
To make terms more succinct and convenient to write and read, the 
following syntactic conventions are being used:
\begin{align*}
	\lambda x_1 x_2 x_3\;...\;x_n.M &\equiv (\lambda x_1.(\lambda x_2.(\lambda x_3.(\;...\;(\lambda x_n.M)\;...\;))))\\
	M_1\;M_2\;M_3\;...\;M_n &\equiv (\;...\;((M_1\;M_2)\;M_3)\;...\;M_n)\\
	\lambda x.x_1\;x_2\;...\;x_n &\equiv (\lambda x.(x_1\;x_2\;...\;x_n))
\end{align*}
The intuition behind the first two rules is rather straightforward, as the rules
seemingly emulate process of \textit{currying}, i.e.
translation between function of multiple arguments \textit{(left-hand side)} and multiple
functions of a single argument \textit{(right-hand side)}. Clearly, this is only
a matter of syntactic simplicity and has no effect on the actual semantics.
The third rule necessitates a precedence of the application rule over the abstraction rule.

Terms can also be given a name---the choice of term names, or \textit{aliases}, is restricted to 
strings of uppercase letters, and strings of numerals.
The means of assigning terms to numeral names is described in section \ref{encoding} -- \textit{Church Encoding}.

\subsubsection{Variable Binding and Substitution}
The substitution of one term for another lies at the very heart of $\lambda$-calculus'
evaluation mechanics, as the idea of evaluating a function is expressed via replacing
abstraction-bound variables with the provided argument. A variable $x$ is bound in $M$,
if occurs as a abstraction variable $\lambda x.M$. The lambda symbol is also called
abstraction operator, and $M$ is the scope thereof. In order to define
reductions and reduction strategies later, first the concept of free
and bound variables must be introduced formally, using inductive definition
of function $\mathrm{FV} : \Lambda \to \big\{\{variable\}\big\}$, mapping 
terms to the respective set of free variables:
%\begin{lstlisting}
%int constant = 8;
%int add_constant(int argument)
%{
%	return argument + constant;
%}
%\end{lstlisting}
\begin{align*}
	\mathrm{FV}(x) &= \{x\} \\
    \mathrm{FV}(M\;N) &= \mathrm{FV}(M) \cup \mathrm{FV}(N) \\
	\mathrm{FV}(\lambda x.M) &= \mathrm{FV}(M) \setminus \{x\}
\end{align*}
\begin{center}
\textit{where $x$ is some variable, and $M$ and $N$ are terms}
\end{center}
For example, $\mathrm{FV}(\lambda x y z.x) = \{\}$, $\mathrm{FV}(\lambda e.y\;e) = \{y\}$,
and $\mathrm{FV}\big((\lambda w.w)\;w\big) = \{w\}$. Some variable $x$ occurring in a term $M$ is
said to be bound, if it is not a member of the set of free variables of the term $M$.
A term $M$, such that $\mathrm{FV}(M) = \{\}$, is called \textit{combinator}.

Although apparently trivial, the substitution of free variables of some term with an another term,
the result being written as $M[x := N]$, can be precarious, for some of the 
free variables of term $N$ can become bound in the resulting term. A simple illustration of this
phenomenon is the following function, $\lambda xy.x$, that could be understood as a function
taking two parameters and returning the first. When this function is partially
applied to a particular argument, $(\lambda xy.x)\;y$, na\"ive replacement of 
the bound variable $x$ for the argument $y$ would yield
$\lambda y.y$, that is, the identity function, a very different result from the expected function returning
the first, already applied parameter $y$, for any input. The solution to this problem leads
to renaming variables in the process of $\alpha$-conversion.

\begin{align*}
	x[x := N] &\equiv N\\
	y[x := N] &\equiv N,\;\;\textit{where}\;x \not= y\\
	(M_1\;M_2)[x := N] &\equiv (M_1[x := N])\;(M_2[x := N])\\
	(\lambda x.M)[x := N] &\equiv \lambda x.M\\
	(\lambda y.M)[x := N] &\equiv \lambda y.(M[x := N]),\textit{ where}\;x \not= y, x \not\in \mathrm{FV}(M) \lor y \not\in \mathrm{FV}(N)\\
	(\lambda y.M)[x := N] &\equiv \lambda s.(M[y := s][x := N]),\textit{ where}\;x \not= y, x\in \mathrm{FV}(M) \land y \in \mathrm{FV}(N)
\end{align*}
\begin{center}
\textit{in the last rule, the variable $s$ stands for such a variable $y_n$,
\\where $n$ is the least natural number such that $y_n \not\in \mathrm{FV}(M) \land y_n \not\in \mathrm{FV}(N)$}
\end{center}

\subsubsection{Reductions and Reduction Strategies}

reduction strats
church rosser

\subsubsection{Church Encoding}
Church encoding is a means of representing data, and operation on them, using
only pure lambda calculus. Because of the simplicity of the evaluation rules, the powerfulness
and expressivity, with which the data and operations are encoded, may seem unexpected.

\paragraph{Church Booleans and logic operators}~\\

$\mathrm{TRUE} \equiv \lambda xy.x$, and $\mathrm{FALSE} \equiv \lambda xy.y$.

After Boolean values are established, the definition of the fundamental
logic operators is desired. It is required that $\mathrm{OR}\;M\;N$ will
reduce to $\mathrm{TRUE}$ if $M$ and $N$ are Church-encoded Boolean values,
or could be reduced into them,
and at least one of the terms $M$ and $N$ can be reduced to $\mathrm{TRUE}$.
Because, in pure lambda calculus, there is no guarantee of validity of
the input, there is no way of predicting the result of an application to
an incorrect argument. \textit{(Later, the problem will be solved by typing
the expressions in section \ref{sec:types} -- Type Systems)}. A term adhering to
such requiremens is:
\begin{align*}
	\mathrm{OR} &\equiv \lambda y x. y\;y\;x\\
	\textit{and similarly, }\mathrm{AND} &\equiv \lambda y x. y\;x\;y
\end{align*}
Another useful construct is a conditional, here expressed as a ternary function
of which the first argument is the Boolean condition itself, returning one
of the remaining arguments based on the condition. The definition of
$\mathrm{ITE}$ \textit{(if---then---else)} is as follows:
\begin{align*}
	\mathrm{ITE} \equiv \lambda xyz.xyz
\end{align*}
This term makes use of the property of $\mathrm{TRUE}$ and $\mathrm{FALSE}$
returning the first, respectively the second, of the two arguments.

\paragraph{Church numerals and arithmetic}~\\ \label{encoding}


\subsubsection{Recursion}
\subsubsection{Implemented Extensions and Syntactic Sugar}

higher order funs

\subsection{Type Systems} \label{sec:types}
\subsubsection{Simply-Typed }
\subsubsection{Hindley-Milner type system}

\section{Evaluator}
\subsection{Goals}
\subsection{Technical Aspects}
javascript lol
\subsection{Features}
info bar

help page


compability table

\subsubsection{User's Input and Parsing}
parser gramamr

\subsubsection{Alias management}

\subsubsection{Display Settings}
alias expansion and shorthand

\subsubsection{Evaluation}
clicking and stuff

\subsubsection{Input \& Output}
using current display settings
printing

latex

files, url
printing

\subsection{Comparision with Existing Solutions}

\section{Conclusion}
It's done, thank you.

\appendix
\section{Examples and Reference Manual}

\end{document}
